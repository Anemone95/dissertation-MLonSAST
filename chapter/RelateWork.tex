\chapter{相关技术综述}
这是章节标题。
注：一般而言，标题不要比小节标题更小，即不要出现1.2.3.4这种标题（本模板支持此类标题，即Subsubsection）。

\section{漏洞挖掘技术}
漏洞挖掘指用自动化或半自动化技术对软件进行本身进行静态，动态分析，检测其是否存在安全漏洞的过程~\cite{liujian2018}。随着软件规模扩大，软件功能种类多样化，安全漏洞其种类也在不断增多，不同漏洞的产生原因不同，利用方式也不同，一种漏洞挖掘技术不能适用于所有漏洞，因此在实践中，人们会在软件开发的各个阶段应用不同类型的技术，本文将这些技术的应用场景主要分为三类：
\begin{itemize}
    \item  白盒测试：也成为静态测试，通常发生在软件编码阶段，对应用程序的源代码或对源码编译产生的二进制文件进行安全性审计，从而发现漏洞。该场景下的技术由于获取了源代码信息，也被称为源码扫描或静态扫描，其可以获得较高的代码覆盖率，发现更多的漏洞，但由于无法运行而产生大量误报，它也是本文系统的应用场景。
    \item 黑盒测试：通常发生在软件测试和运行阶段，对应用程序动态运行，并输入数据，分析程序反应从而发现漏洞。适用于该场景的技术可以在程序只暴露接口的情况下展开测试，因此应用广泛，同时动态运行程序使其获得更低的误报，甚至产生漏洞利用报告，但由于如今应用程序复杂，自动化测试技术往往无法覆盖所有的代码逻辑。
    \item 灰盒测试：介于白盒和黑盒之间的一种测试，这一场景下的技术往往通过软件插桩或是逆向工程，不但关注程序输入输出信息，还可以了解部分程序内部逻辑。因此具备上述两种测试的优点，许多黑白盒测试技术稍加改造也可以变为灰盒测试技术，但由于其终究还是需要获取程序本身，以及需要动态运行，适用性比纯黑百盒测试弱。
\end{itemize}

在漏洞挖掘技术发展早期，每一种技术往往只能应用于一种特定场景，但随着研究者的不断完善和改进，如今一种技术也可以适用于多种场景，并且技术本身也产生了相互组合，对其正交分类较为困难，本章就目前常用的漏洞挖掘技术进行分类并分别进行简要介绍~\cite{liujian2018,meihong2009}。


% 需要写java的常见漏洞吗？
\subsection{基于代码分析的漏洞挖掘技术}
这一类漏洞挖掘技术侧重于对程序代码本身进行分析，同时对漏洞产生原理进行建模，将程序分析结果结合漏洞模型发掘漏洞。主要有词法分析技术，数据流分析技术，形式化分析技术和符号执行技术。\\
\subsubsection{词法分析技术}

\subsubsection{数据流分析技术}

\subsubsection{形式化方法分析技术}
形式化方法分析主要思想是将软件代码性质进行形式化描述，再判断该描述是否满足漏洞特征的一类分析方法~\cite{B:automatedTheoremProving}，其中定理证明技术是形式化代码分析技术的主要代表，主要运用于白盒测试场景。

%https://firmianay.gitbooks.io/ctf-all-in-one/doc/5.0_vulnerability.html
%Automated Theorem Proving in Software Engineering
%https://github.com/leanprover/lean2
定理证明技术将漏洞存在（或不存在）定义为一定理，再将源程序代码特征转化为数学表达形式，最后对数学表达进行逻辑推理，若定理存在性得以证明，则漏洞存在（或不存在），即漏洞挖掘过程类似于数学上的定理证明过程。主要代表性工具有infer~\footnote{\url{https://fbinfer.com/}}~\cite{atp:infer}, ESC/Java~\cite{atp:escjava}和saturn~\cite{atp:saturn}。

该技术作为一种使用严格的数理逻辑推理作为检测手段的技术，具有极低的误报率，但由于其需要针对特定漏洞构建数学条件，其过程需要大量的人工参与，有的漏洞甚至难以用断言结构表达，适用于死循环，资源泄露，空指针等问题，对新漏洞的扩展性不高，同时，如何将大规模程序应用于形式化方法分析也成为工业界亟待解决的问题。 \\

\subsubsection{符号执行技术}
符号执行技术是一种将程序执行可达性问题转化为约束求解问题，并以此进行漏洞挖掘的技术~\cite{sym:sum}。
% https://www.youtube.com/watch?v=mffhPgsl8Ws
% https://blog.csdn.net/wcventure/article/details/86773290
%Symbolic Execution for Software Testing: Three Decades Later

具体来说，符号执行包含一个符号状态表$\sigma$和一个符号路径约束$PC$，开始时，$\sigma=\empty, PC=true$，每读取一条语句，就将变量抽象为约束求解中的变量、常量或他们的表达式放入$\sigma$中，特别的，当遇到条件判断$if(e)$时，将if分支的$PC$更新为$PC \wedge \sigma(e)$，将else分支的$PC'$更新为$PC\wedge \neg\sigma(e)$，随后使用约束求解器求解$PC$和$PC'$，如果约束不满足，则停止对该分支的解析，因为该分支不可达。当符号执行遇到程序崩溃、预先定义的漏洞语句、或是程序正常退出时，整个分析停止，同时可以计算可以到达停止点的输入。

符号执行可以分析程序中的控制流，覆盖更多的代码，另外其使用约束求解模拟执行程序的方法也有效降低了误报率，但传统符号执行严重依赖于约束求解器的能力，例如，若约束求解器不能处理非线性计算，或是整个程序中存在无法分析的第三方库，那么整个分析将无法继续。为解决这些问题，研究者们提出了动态符号执行的想法~\cite{sym:dart,sym:cute,sym:exe,sym:klee}，但其在实际应用中仍不是很广泛，主要原因在于其需要大量计算资源，甚至在处理大规模程序时，出现的路径爆炸问题会导致约束求解无法产生结果。\\

\subsection{基于模糊测试的漏洞挖掘技术}

\subsection{基于机器学习的漏洞挖掘技术}

\section{污点传播算法}

\subsection{污点传播原理介绍}

\subsection{污点传播的优势}

\subsection{污点传播的不足}

\section{程序切片技术}
\subsection{程序切片技术介绍}

\subsection{后向程序切片的优势}

\section{词嵌入技术}
（后期可能会改为文档嵌入技术，先不写）

\section{LSTM算法}
\subsection{LSTM原理介绍}
\subsection{LSTM的优势}

\section{本章小结}