\chapter{引言}

\section{项目背景和意义}
% 1 pages
% 漏洞多
随着网络技术和应用飞速发展，信息系统安全正面临着前所未有的挑战。网络化和互联互通性已经成为当前软件和信息系统发展的大势所趋，互联网导致系统攻击面增大，使系统面临的安全威胁空前增加。另一方面，随着软件和信息系统的业务不断丰富，复杂性也不断提高，这不仅使漏洞利用方式不断增加，而且使漏洞检测难度不断提高，尽管开发者已经投入了大量精力进行安全编程，但是软件漏洞仍然存在，并将继续成为一个重大问题~\cite{vuldeepecker}。根据国际通用漏洞发布组织MITRE统计，在1999年，仅有1600个通用漏洞（CVE，Common Vulnerabilities and Exposures）被发现；到了2014年，新发现的 CVE 数量已接近10000个~\cite{liujian2018}；而至今（2020年1月26日），该数字已经上升到了129695个~\footnote{\url{https://cve.mitre.org/cve/}}。同时，根据国家互联网应急中心（CNCERT/CC，National Computer Network Emergency Response Technical Team/Coordination Center of China）的报告~\footnote{\url{https://www.cert.org.cn/publish/main/upload/File/2019 First half year .pdf}}显示，仅 2019 年上半年，国家信息安全漏洞共享平台（CNVD）就收录了通用型安全漏洞5859个，其中Web漏洞占比24.9\%，位居第二。

% 危害大
从以往发生的安全事件来看，针对 Web 漏洞的攻击可导致的后果极为严重，一个网站系统只要有一处脆弱点，攻击者将会使用一切手段对该网站发起攻击，篡改网页内容，窃取服务器数据甚至在服务器中执行恶意代码，造成更严重的后果。

% 静态扫描重要性
源代码安全是保证软件安全的基础。对于源代码进行安全扫描，可以在源头处杜绝安全问题，根据2019年中国软件评测中心的《2019大中型政企机构网络安全建设发展趋势研究报告》显示，进行源码扫描能有效减少10\%-50\%安全漏洞，降低软件安全建设和运维成本。因此，源码安全日益受到中大型政企机构的重视，在此方面投入也不断提高，其中，构建一款具有高准确率的静态代码分析（SCA，static code analysis）系统显得尤为重要~\cite{aletheia}。

% 目前静态扫描存在不足
由于软件数量和规模扩大，人们总希望能够通过自动化技术发现代码中的漏洞，从开源工具到商业工具，从工程实践到学术领域，目前已有许多关于代码静态扫描系统的应用和研究~\cite{li2016vulpecker,leopard,sym:exe,taint:finding,vuldeepecker,taint:taj,Koc2019,sym:cute,atp:saturn,sym:klee,atp:escjava,Koc2017,pixy,aletheia}。然而目前静态代码分析系统仍存在或多或少的问题，在工业界，SCA 使用基于模式匹配、数据流分析等技术，往往希望不漏掉真实漏洞——不产生漏报，但是它们产生了大量误报~\cite{falseAlarm,aletheia,falsepositive}。过高的误报使人工审核任务加重，让安全工程师将大量精力浪费在无害代码上~\cite{leopard}。在实际生产中，安全工程师为了权衡误报与漏报，必须不断地设计更加精巧的扫描规则，再一次加重了安全工程师负担~\cite{taintStyle,vuldeepecker}，并对安全工程师个人经验有很高的要求。学术界对提高 SCA 的准确性进行了更深入的研究，引入了诸如符号执行，机器学习等技术，但是受限于计算能力，它们往往只能应对小规模代码项目，如何让学术界成果应用到工业界，使其适应大规模程序，是安全工程师亟待考虑的问题。

% 本文工作
本文旨在设计一款基于污点传播和机器学习的Java静态代码扫描系统，通过污点传播、程序切片和双向长短记忆网络（BLSTM, Bidirectional Long Short-Term Memory）技术，提供准确的安全扫描服务。具体来说，用户输入一个已编译好的 Jar 包后，该系统以污点分析为基础，先产生一个初步的漏洞结果。由于污点分析存在过污染、无法识别清洁函数问题，该结果存在大量误报，接着系统根据初步结果进行分解，将其划分为多个子污染流，对每个污染流进行后向程序切片，并用 BLSTM 算法模型预测切片是否能够向下传播污点，从而推导每个漏洞实例是否可利用，并将疑似误报的漏洞威胁等级降低，以此让安全工程师或软件开发人员将更多注意力放在更可能为漏洞的结果上。同时，用户可以对漏洞进行标注，通过模型周期性的迭代学习，预测准确率将不断提高。系统对于污点分析得到的传播路径进行拆解，通过限制调用图和去依赖切片技术，解决了学术工具只能应对小规模程序的问题，填补了学术界和工业界的鸿沟，而基于学术界前沿工作，本系统相对于传统扫描工具结果更准确。

\section{研究现状}
本系统旨在利用传统方法配合机器学习对 Java 软件源代码进行静态安全扫描，因此本节将详细介绍工业界传统静态代码分析系统应用现状和学术界基于机器学习的静态安全扫描研究现状。

\subsection{传统静态代码分析系统应用现状}

在项目上线前对项目代码进行静态扫描已经成为软件开发中的最佳实践，在实际操作中，各个企业会根据实际情况使用第三方或自研静态扫描产品。本小节就目前常用扫描产品和静态扫描技术进行介绍。

目前静态安全扫描产品使用的技术主要有词法分析技术、数据流分析技术和形式化分析技术。词法分析技术主要是对代码中敏感函数进行匹配，从而发现安全性漏洞，这一类分析技术产生时间较早，实现也较为简单，但是由于其不考虑程序上下文，存在大量误报，在实际情况中使用较少。

数据流分析技术模拟程序中敏感数据流动从而发现安全漏洞，其衍生出的污点分析方法是目前实际使用的主要检测方法，这一类分析方法适合于数组越界，注入类漏洞，因为这些漏洞特征表现为特定变量在某一程序点上状态满足或不满足某一规则，通过对数据的跟踪恰好可以识别这些特征。由于其能覆盖的漏洞种类较多，本系统选择以该技术为预测的基础，然而随着目前程序规模不断扩大，新型程序设计思想和语法不断出现，加之漏洞成因愈发复杂，即使是这类分析技术目前也存在大量误报，例如污点分析无法很好的处理容器变量、控制流、清洁函数等，企业中的安全运营人员必须通过手工设计精巧的污点传播规则，限制开发者所用的清洁函数，或是以手工添加函数摘要的方式添加清洁函数等方式降低误报，然而这些方式并不能完全解决污点分析的弊端，仍有误报不断产生，安全工程师需要花大量时间处理误报。
   
形式化分析技术往往用于一些可以用数学逻辑表达的安全漏洞，如 C/C++ 语言中指针变量二次释放，缓冲区溢出等问题，这一类技术将漏洞存在性问题变为数学逻辑上的约束求解和逻辑推导问题，由于目前程序规模较大，该技术面临着求解规模空间大，无法推导等问题，此外该技术针对的漏洞类型较少，将问题转变为数学模型需要大量人力成本。

目前商业 SCA 主要有 Fortify SCA~\footnote{\url{https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview}}、LGTM~\footnote{\url{https://lgtm.com/}}，Infer~\footnote{\url{https://infer.liaohuqiu.net/}}等。Fortify 为老牌安全扫描工具，其主要结合词法分析，数据流分析、配置分析等扫描技术，但就像前文所说，其默认规则存在大量误报；LGTM 为较为新型的安全扫描器，是 Google、微软所使用的安全扫描器之一，其创新点在于其通过定义 QL 语法编写扫描器规则，将扫描逻辑和规则逻辑分离，使安全工程师能够较快地编写规则；Infer 为 Facebook 所使用的安全扫描器之一，也是少数使用形式化分析技术实现的扫描器，其使用分离逻辑和双向假说推理的思想，解决了传统形式化分析求解规模过大的问题，但其检测能力目前只限于资源泄露，空指针漏洞，不能用于其他类型（如常见的 OWASP TOP 10）的漏洞检测。

\subsection{基于机器学习的静态安全扫描研究现状}

为解决传统扫描器高误报、需要花大量人力定义规则等问题，随着机器学习领域的不断发展，学术界也一直在探索机器学习在静态安全扫描上的应用。

研究初期，研究者们提出了一些半智能化的扫描方案~\cite{aletheia,zranking,ayukselCaseStudy}，这些方案主要由人工定义代码特征（如：语句长度，关键 API 调用位置等），并使用传统的机器学习算法进行分类。这一类工作的人工标记思路与本系统类似，然而由于其仍需要手工设计特征、泛化能力较弱等原因，并没有得到大面积推广。

随着研究工作不断深入，部分研究者提出通过相似度识别漏洞~\cite{vuddy,li2016vulpecker}，它的主要思想是如果一个待测代码片段 A 与已有代码片段 B 在某漏洞特征上具有高相似度，并且已知代码 B 为漏洞代码，那么代码 A 就很可能也为漏洞代码。在特征工程上，研究者们分别将代码特征抽象为词向量~\cite{vuddy}、树和图~\cite{simtree}，以此比较相似性。李珍等学者提出 VulPecker~\cite{li2016vulpecker} 从六个维度定义多个代码特征并且设计多种相似度算法，他们认为不同类型漏洞适用于不同特征和相似算法，并且一个优秀的相似度算法可以将含漏洞和安全代码进行区分，因此设计相似度算法选择器，通过已有漏洞代码库（NVD）和补丁信息训练相似度算法选择器，得到<漏洞类型, 算法>对应关系，当有新的被测代码输入时，通过各类漏洞的相似度算法识别代码是否有这些漏洞。这类工作的优势在于不需要大量标记数据集即可进行扫描，但是大多数工作仍需要手工设计特征，并且代码识别精度较低，因此并没有得到大规模使用。

还有部分研究者使用深度学习直接提取代码特征，将识别漏洞代码问题转化为分类问题~\cite{vuldeepecker,Koc2017,Koc2019}。李珍等学者提出的 VulDeePecker~\cite{vuldeepecker} 是这一方向的代表工作之一，该工具首先抽取与安全 API 相关的程序代码（文中称其为 gadgets，它们类似于对调用安全 API 位置的后向切片），再将其代码转化为向量，结合标记后使用 BLSTM 学习，当输入待测代码后，将其做相同的向量化操作，再由 BLSTM 预测其是否为漏洞，经过试验，该工具在数据集上具有较高准确率，并且在 3 款实际软件中发现了 4 个未知漏洞，但是该工具只能预测 C/C++ 程序的漏洞，并且在切片时没有考虑控制流信息；Koc 等人提出使用机器学习降低污点传播误报率的方法~\cite{Koc2017}，他们在文中总结了污点传播的误报模式，并且提出使用对方法体进行程序切片和 LSTM 预测降低误报率的想法，经过试验，他们认为该方法能够有效降低误报；在 2019 年， Koc 等人对先前工作展开进一步实证研究~\cite{Koc2019}，对比手工设计特征、词袋结合随机森林、程序切片结合 BLSTM 和程序切片结合图神经网络（GNN）的预测效果，实验证明，BLSTM 组预测效果普遍优于其他组，并且，在切片后对切片进行泛化处理可以大大提高预测效果。Koc 等人工作是本系统的主要参考，对于函数体，本系统也是用类似的切片技术和预测技术，然而，他们工作中提到程序切片只适用于小规模程序的问题，因此他们工具只能对于漏洞的最后一个函数体（污点传播汇聚点）进行切片，由于污点是否能够传播并不等价于污点是否能够在汇聚点传播，因此无法用于实际使用，本系统创新性的提了分解污点传播过程和限制调用图切片方法，解除这一限制，即本系统可以对污染传播全流程进行切片和预测，保证预测结果准确性。

% 不是机器学习的，先忽视
%Du 等人提出并实现了一个轻量级的通用框架LEOPARD~\ref{leopard} ，旨在通过复杂度和漏洞特征识别存在漏洞的函数，他们认为函数的复杂度并不直接与存在漏洞的可能性相关，即使简单函数也可能产生漏洞，因此他们将漏洞识别分为两个阶段，在第一阶段首先用复杂性特征（如嵌套循环数、圈复杂度等）将程序函数进行分类，在第二阶段用漏洞特征（指针数量、控制语句数量等）对函数进行排序，排序考前的函数被认为是存在风险的，他们的技术对于漏洞的最小识别单位为函数级别。


\section{本文主要研究工作}
为解决传统扫描工具检测误报率高的问题，本系统实现一款基于污点分析、程序切片和 BLSTM 的静态代码扫描系统。该系统面向 Java 语言，以开发者编译后得到的 Jar 包为输入，提供准确的漏洞扫描报告，从而减轻安全工程师工作量，加快软件开发效率。本文主要研究工作如下。

本文首先分析目前常用程序安全分析技术的原理和优缺点，选择静态污点分析作为系统的基础分析方法，然后根据学术界前沿研究成果，选择基于 Joana 的后向程序切片和 BLSTM 作为误报预测方法，最后分析用户需求设计系统架构，将系统分为污点分析模块，程序切片模块，数据预处理模块和误报预测模块，以 C/S 架构向用户提供服务。

在污点分析模块，本系统以 Find Security Bugs  工具\footnote{\url{https://find-sec-bugs.github.io/}，最初为 FindBugs~\cite{taint:finding}，如今被拆分成 Spotbugs 和 Find Security Bugs 插件，Spotbugs 提供 UI 和数据流基本分析框架，Find Security Bugs 提供污点分析框架和大量扫描规则，下文中提 到 Find Security Bugs 实际指 Spotbugs 和 Find Security Bugs。}的污点分析为基础，改进其分析流程，对用户提交的 Jar 包集合进行污点分析，输出污点分析报告，与原始 Find Security Bugs 不同，本系统在报告中不仅报告代码中潜在漏洞项、代码位置之外，还额外向用户展示可能被利用的污点传播路径，路径由污点传播树表示，一方面让用户更清晰地了解漏洞发生原理，快速判断误报，另一方面为程序切片提供依据。

在程序切片模块，系统基于 Joana 实现了一套适用于实际应用程序的切片器，完成无依赖切片、限制调用图规模切片和异构 Jar 包的切片。具体来说，对于上一模块报告中的污点传播树，系统对其相关函数拆分，得到污染流，对污染流进行限制规模切片，进一步缩小切片规模，为系统稳定运行和准确预测提供保障。

\begin{definition}[污点传播树]
    污点传播树是反映污点传播的树形数据结构，树中根节点为调用入口函数的调用者函数，树中其他节点为函数调用信息或返回语句信息，由于同一层节点存在顺序，由孩子兄弟表示法表示。
\end{definition}

\begin{definition}[污点传播流]
    污点传播流用于指导切片的一种数据结构，实际为函数摘要至关键点行号的二元组。
\end{definition}

在预处理模块，系统参考 Koc 等学者工作~\cite{Koc2019}和实际应用的切片内容，提出一套适用于实际应用代码的泛化和向量化方案，保证预测模型快速收敛和用户对准确性的要求。

在误报预测模块，系统基于 Pytorch 实现经典的 BLSTM 神经网络三层架构，通过该模型预测污染流是否能够传播污点，若一棵传播树中存在一处传播流无法传播污点，那么该传播树表示的传播路径被标记为不可利用，当一个漏洞实例的所有传播树不可利用时，系统推导得到该漏洞实例为误报，经过试验，该模型可以准确预测误报。同时系统基于 Django、Celery 和 MySQL 等技术实现后台服务，用户可以根据需要定制模型各项参数并定时触发模型训练流程。

综上，本系统将学术界前沿技术成功运用到实际生产中，首次提出对污点分析结果拆分，将漏洞预测任务转化为污点传播树中子污染流是否安全的预测任务；改进后向切片器，通过限制调用图的方式保证切片过程在绝大多数污染流上能够顺利进行，从而保证系统在各类规模程序上都能提供准确的漏洞扫描报告。

\section{本文组织结构}
本文共分为五个章节，组织结构如下：

第一章，引言部分，介绍本系统背景和意义，分析当前关于静态安全扫描的研究现状以及介绍本文主要研究工作。

第二章，介绍相关技术，介绍目前较常见的漏洞挖掘技术，对比相关技术优缺点，说明本系统的技术方案，并对系统中使用的核心技术如污点分析，程序切片和 BLSTM 算法进行介绍。

第三章，Java静态安全扫描系统的需求分析和设计，首先介绍系统整体概述，分析系统功能性和非功能性的需求，接着说明系统总体设计，再分模块从类图和流程两方面分别说明模块设计。

第四章，Java静态安全扫描系统实现和测试，对于各个模块的实现细节结合漏洞实例代码进行详细说明，接着介绍系统的功能测试、健壮性和性能测试，对系统预测效果进行评估，最后展现系统运行效果。

第五章，总结和展望，对本系统和论文的工作进行总结，并提出本系统的不足和未来工作方向。